#!/usr/bin/env python
# -*- coding:utf-8 -*-

from datetime import date

logics=[
    "AUFLIA", 
    "AUFLIRA", 
    "AUFNIRA",
#    "BVFP", 
    "LIA", 
    "LRA", 
    "QF_ABV", 
    "QF_AUFBV", 
    "QF_AUFLIA", 
    "QF_AX", 
    "QF_BV", 
    "QF_IDL", 
    "QF_LIA", 
    "QF_LRA", 
    "QF_NIA", 
    "QF_NRA", 
    "QF_RDL", 
    "QF_UFBV", 
    "QF_UFIDL", 
    "QF_UFLIA", 
    "QF_UFLRA", 
    "QF_UFNRA", 
    "QF_UF", 
    "UFLRA", 
    "UFNIA"]

for logic in logics :
    logic_fol = True # TODO Currently unused
    logic_qf = False
    logic_array = False
    logic_uf = False
    logic_bv = False
    logic_linear = False
    logic_dl = False # TODO Currently unused.  Discuss: a tag????
    logic_int = False
    logic_real = False
    logic_fp = False # TODO Currently unused
    logic_string = False # TODO Currently unused
    tmp = logic
    # decripting the logic
    if tmp.startswith("QF_") :
        logic_qf = True
        tmp = tmp[3:]
    if tmp.startswith("AX") :
        logic_array = True
        tmp = tmp[2:]
    if tmp.startswith("A") :
        logic_array = True
        tmp = tmp[1:]
    if tmp.startswith("UF") :
        logic_uf = True
        tmp = tmp[2:]
    if tmp.startswith("BV") :
        logic_bv = True
        tmp = tmp[2:]
    if tmp.startswith("IDL") :
        logic_linear = True
        logic_dl = True
        logic_int = True
        tmp = tmp[3:]
    if tmp.startswith("RDL") :
        logic_linear = True
        logic_dl = True
        logic_real = True
        tmp = tmp[3:]
    if tmp.startswith("L") :
        logic_linear = True
    if tmp.startswith("L") or tmp.startswith("N") :
        tmp = tmp[1:]
        if tmp.startswith("I") :
            tmp = tmp[1:]
            logic_int = True
        if tmp.startswith("R") :
            tmp = tmp[1:]
            logic_real = True
        assert(tmp.startswith("A"))
        tmp = tmp[1:]
    print
    assert(tmp == "")

    # computing module list
    import_string = ["Core"]
    if logic_array :
        import_string.append("ArrayEx")
    if logic_bv :
        import_string.append("FixedSizedBitVectors")
    if logic_fp :
        import_string.append("FloatingPoints")
    if logic_int :
        import_string.append("Ints")
    if logic_real :
        import_string.append("Reals")
    if logic_string :
        import_string.append("UnicodeStrings")

    afile = open(logic+"_autogen.smt3", 'w')
    afile.write("(define-module "+logic+"\n")
    afile.write(" (\n")
    # here should come set info notes

    today = date.today()
    afile.write("  (set-info :smt-lib-version 3.0)\n")
    afile.write("  (set-info :smt-lib-release \"2020-XX-XX\")\n")
    afile.write("  (set-info :written-by \"Clark Barrett, Pascal Fontaine and Cesare Tinelli\")\n")
    afile.write("  (set-info :date \""+today.strftime("%Y-%m-%d")+"\")\n")
    afile.write("  (set-info :last-updated \""+today.strftime("%Y-%m-%d")+"\")\n")
    afile.write("  (set-info :update-history\n")
    afile.write("   \"Autogenerated from logic_autogen.py.\n")
    afile.write("   \"\n")
    afile.write("  )\n\n")

    # writing import command
    afile.write("\n")
    afile.write("  (import (")
    first = True;
    for i in import_string:
        if first:
            first = False
        else:
            afile.write(" ")
        afile.write(i)
    afile.write("))\n")
    # writing open commands
    for i in import_string:
        afile.write("  (open " + i + ")\n")
    afile.write(" )\n\n")
    # writing types
    afile.write(" :types (\n")
    afile.write("  Bool\n")
    if logic_array :
        afile.write("  (-> (! Type :var A) (! Type :var B) (Array A B))\n")
    if logic_bv :
        afile.write("  (-> (! Int :var m :syntax ⟨pos_numeral⟩ :restrict (> m 0)) (BitVec m))\n")
    if logic_fp :
        afile.write("  (-> (! Int :var eb :syntax ⟨pos_numeral⟩ :restrict (> eb 1))\n")
        afile.write("      (! Int :var sb :syntax ⟨pos_numeral⟩ :restrict (> sb 1))\n")
        afile.write("      (FloatingPoint eb sb))\n")
        afile.write("  RoundingMode\n")
        afile.write("  Float16\n")
        afile.write("  Float32\n")
        afile.write("  Float64\n")
        afile.write("  Float128\n")
    if logic_int :
        afile.write("  Int\n")
    if logic_real :
        afile.write("  Real\n")
    if logic_string :
        afile.write("  String\n")
        afile.write("  Lan\n")
    afile.write("  )\n\n")
    # writing consts
    afile.write(" :consts (\n")
    
    afile.write("    (true Bool)\n")
    afile.write("    (false Bool)\n")
    afile.write("    (ite (-> (! Type :var A :implicit) Bool A A A))\n")
    afile.write("    (not (-> Bool Bool))\n")
    afile.write("    (= (-> (! Type :var A :implicit) A A Bool))\n")
    afile.write("    (distinct (-> (! Type :var A :implicit) A A Bool))\n")
    afile.write("    (and (-> Bool Bool Bool))\n")
    afile.write("    (or (-> Bool Bool Bool))\n")
    afile.write("    (=> (-> Bool Bool Bool))\n")
    afile.write("    (xor (-> Bool Bool Bool))\n")

    if not logic_qf :
        afile.write("    (forall (-> (! Type :var A :implicit) (-> A Bool) Bool))\n")
        afile.write("    (exists (-> (! Type :var A :implicit) (-> A Bool) Bool))\n")
    if not logic_fol :
        afile.write("    (choose (-> (! Type :var A :implicit) (-> A Bool) A))\n")

    if logic_array :
        afile.write("    (select (-> (! Type :var I :implicit)\n")
        afile.write("                (! Type :var E :implicit)\n")
        afile.write("                (Array I E) I E))\n")
        afile.write("    (store (-> (! Type :var I :implicit)\n")
        afile.write("               (! Type :var E :implicit)\n")
        afile.write("               (Array I E) I E (Array I E)))\n")

    if logic_int :
        afile.write("    (⟨numeral⟩ Int)\n")
        if not logic_linear : # TODO is this right?
            afile.write("    (abs (-> Int Int))\n")
            afile.write("    (+1 (-> Int Int))\n")
            afile.write("    (-1 (-> Int Int))\n")
        afile.write("    (+ (-> Int Int Int))\n")
        afile.write("    (- (-> Int Int Int))\n")
        if logic_linear :
            afile.write("    (* (-> (! Int :syntax ⟨int_value⟩) (! Int :syntax ⟨symbol⟩) Int)) ; linear multiplication\n")
            afile.write("    (* (-> (! Int :syntax ⟨symbol⟩) (! Int :syntax ⟨int_value⟩) Int)) ; linear multiplication\n")
        else :
            afile.write("    (* (-> Int Int Int))\n")
        afile.write("    (> (-> Int Int Bool))\n")
        afile.write("    (>= (-> Int Int Bool))\n")
        afile.write("    (< (-> Int Int Bool))\n")
        afile.write("    (<= (-> Int Int Bool))\n")
        if not logic_linear :
            afile.write("    (divisible (-> Int (! Int :syntax ⟨pos_numeral⟩) Int))\n")
            afile.write("    (mod (-> Int Int Int))\n")
        if not logic_fol : # TODO discuss
            afile.write("    (sum (-> Int Int (-> Int Int) Int))\n")

    if logic_real :
        afile.write("    (⟨decimal⟩ Real)\n")
        afile.write("    (- (-> Real Real))\n")
        afile.write("    (+ (-> Real Real Real))\n")
        if logic_linear :
            afile.write("    (* (-> (! Real :syntax ⟨real_value⟩) (! Real :syntax ⟨symbol⟩) Real))\n")
            afile.write("    (* (-> (! Real :syntax ⟨symbol⟩) (! Real :syntax ⟨real_value⟩) Real))\n")
        else :
            afile.write("    (* (-> Real Real Real))\n")
        afile.write("    (<= (-> Real Real Bool))\n")
        if logic_int :
            afile.write("    (is_int (-> Real Bool))\n")
        afile.write("    (- (-> Real Real Real))\n")
        if logic_linear :
            afile.write("    (/ (-> (! Int :value)\n")
            afile.write("           (! Int :var d :value :restrict (> (to_real d) 0.0))\n")
            afile.write("           Real))\n")
        else : # TODO discuss: I do not believe we have to introduce any restriction, do we?
            afile.write("    (/ (-> Real Real Real))\n")
        afile.write("    (< (-> Real Real Bool))\n")
        afile.write("    (> (-> Real Real Bool))\n")
        afile.write("    (>= (-> Real Real Bool))\n")
        if not logic_fol : # TODO discuss
            afile.write("    (sum (-> Real Real (-> Real Real) Real))\n")
        if logic_int :
            afile.write("    (to_int (-> Real Int))\n")
            afile.write("    (to_real (-> Int Real))\n")

    if logic_string :
        afile.write("    (⟨string⟩ String)\n")
        afile.write("    (char (-> (! Int :var m :syntax ⟨int_value⟩ :implicit\n")
        afile.write("               :restrict (or (= m 4) (= m 8) (= m 12) (= m 16) (= m 20) (= m 24)))\n")
        afile.write("              (! (BitVec m) :value)\n")
        afile.write("           String))\n")

        afile.write("    (++ (-> String String String))\n")
        afile.write("    (< (-> String String Bool))\n")
        afile.write("    (<= (-> String String Bool))\n")

        afile.write("    (to_lan (-> String Lan))\n")
        afile.write("    (in (-> String Lan Bool))\n")
        afile.write("    (empty Lan)\n")
        afile.write("    (univ Lan)\n")
        afile.write("    (allchar Lan)\n")
        afile.write("    (++ (-> Lan Lan Lan))\n")
        afile.write("    (union (-> Lan Lan Lan))\n")
        afile.write("    (inter (-> Lan Lan Lan))\n")
        afile.write("    (* (-> Lan Lan))\n")
        afile.write("    (len (-> String Int))\n")
        afile.write("    (substr (-> String Int Int String))\n")
        afile.write("    (at (-> String Int String))\n")
        afile.write("    (prefixof (-> String String Bool))\n")
        afile.write("    (suffixof (-> String String Bool))\n")
        afile.write("    (contains (-> String String Bool))\n")
        afile.write("    (indexof (-> String String Int Int))\n")
        afile.write("    (replace (-> String String String String))\n")
        afile.write("    (replace_all (-> String String String String))\n")
        afile.write("    (diff (-> Lan Lan Lan))\n")
        afile.write("    (comp (-> Lan Lan))\n")
        afile.write("    (+ (-> Lan Lan))\n")
        afile.write("    (opt (-> Lan Lan))\n")
        afile.write("    (range (-> String String Lan))\n")
        afile.write("    (^ (-> (! Int :syntax ⟨int_value⟩) Lan Lan))\n")
        afile.write("    (loop (-> (! Int :var i :syntax ⟨int_value⟩ :restrict (>= i 0))\n")
        afile.write("              (! Int :var n :syntax ⟨int_value⟩ :restrict (>= n 0))\n")
        afile.write("              Lan Lan))\n")
        afile.write("    (is_digit (-> String Bool))\n")
        if logic_int :
            afile.write("    (to_code (-> String Int))\n")
            afile.write("    (from_code (-> Int String))\n")
            afile.write("    (to_int (-> String Int) )\n")
            afile.write("    (from_int (-> Int String))\n")

    if logic_bv :
        afile.write("    (⟨hexadecimal⟩\n")
        afile.write("      (-> (! Int :var m :syntax ⟨int_value⟩ :restrict (> m 0) :implicit\n")
        afile.write("        :restrict \"m is 4 times the number of hexadecimal digits in the constant\")\n")
        afile.write("        (BitVec m)))\n")
        afile.write("    (⟨binary⟩\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit\n")
        afile.write("        :restrict \"m is the number of binary digits in the constant\")\n")
        afile.write("        (BitVec m)))\n")
        afile.write("    (to_bv (-> Boolean (BitVec 1)))\n")
        afile.write("    (concat\n")
        afile.write("      (-> (! Int :var i :syntax ⟨numeral⟩ :implicit :restrict (> i 0))\n")
        afile.write("          (! Int :var j :syntax ⟨numeral⟩ :implicit :restrict (> j 0))\n")
        afile.write("          (! Int :var k :syntax ⟨numeral⟩ :implicit :restrict (= k (+ i j)))\n")
        afile.write("          (BitVec i) (BitVec j)\n")
        afile.write("          (BitVec k)))\n")
        afile.write("    (extract\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (! Int :var i :syntax ⟨numeral⟩ :restrict (< i m))\n")
        afile.write("          (! Int :var j :syntax ⟨numeral⟩ :restrict (<= 0 j i))\n")
        afile.write("          (! Int :var k :syntax ⟨numeral⟩ :implicit :restrict (= n (+1 (- i j))))\n")
        afile.write("          (BitVec m) (BitVec k)))\n")
        afile.write("    (repeat\n")
        afile.write("      (-> (! Int :var i :syntax ⟨numeral⟩ :restrict (> i 0))\n")
        afile.write("          (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (! Int :var n :syntax ⟨numeral⟩ :implicit :restrict (= n (* m i)))\n")
        afile.write("          (BitVec m) (BitVec n)))\n")
        afile.write("    (bvnot\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m))\n")
        afile.write("    (bvand\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvor\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvnand\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvnor\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvxor\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvxnor\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvcomp\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec 1))\n")
        afile.write("    (bvneg\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m))\n")
        afile.write("    (bvadd\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvmul\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvudiv\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvurem\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvsub\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvsdiv\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvsrem\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvsmod\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvult\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) Bool)\n")
        afile.write("    (bvule\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) Bool)\n")
        afile.write("    (bvugt\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) Bool)\n")
        afile.write("    (bvuge\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) Bool)\n")
        afile.write("    (bvslt\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) Bool)\n")
        afile.write("    (bvsle\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) Bool)\n")
        afile.write("    (bvsgt\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) Bool)\n")
        afile.write("    (bvsge\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) Bool)\n")
        afile.write("    (bvshl\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bvlshr\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec m))\n")

        afile.write("    (zero_extend\n")
        afile.write("      (-> (! Int :var i :syntax ⟨numeral⟩ :restrict (> i 0))\n")
        afile.write("          (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (! Int :var n :syntax ⟨numeral⟩ :implicit :restrict (= n (+ m i)))\n")
        afile.write("          (BitVec m) (BitVec n))\n")
        afile.write("    (sign_extend\n")
        afile.write("      (-> (! Int :var i :syntax ⟨numeral⟩ :restrict (> i 0))\n")
        afile.write("          (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (! Int :var n :syntax ⟨numeral⟩ :implicit :restrict (= n (+ m i)))\n")
        afile.write("          (BitVec m) (BitVec n))\n")
        afile.write("    (rotate_left\n")
        afile.write("      (-> (! Int :var i :syntax ⟨numeral⟩ :restrict (> i 0))\n")
        afile.write("          (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m))\n")
        afile.write("    (rotate_right\n")
        afile.write("      (-> (! Int :var i :syntax ⟨numeral⟩ :restrict (> i 0))\n")
        afile.write("          (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m))\n")
        afile.write("    (pop_count\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m))\n")
        afile.write("    (reduce_and\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec 1))\n")
        afile.write("    (reduce_or\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec 1))\n")
        afile.write("    (reduce_xor\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec 1))\n")
        afile.write("    (bvite\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec 1) (BitVec m) (BitVec m) (BitVec m))\n")
        afile.write("    (bv1ult\n")
        afile.write("      (-> (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
        afile.write("          (BitVec m) (BitVec m) (BitVec 1))\n")

    if logic_fp :
        afile.write("    (roundNearestTiesToEven RoundingMode)\n")
        afile.write("    (roundNearestTiesToAway RoundingMode)\n")
        afile.write("    (roundTowardPositive RoundingMode)\n")
        afile.write("    (roundTowardNegative RoundingMode)\n")
        afile.write("    (roundTowardZero RoundingMode)\n")
        afile.write("    (fp\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var  i :syntax ⟨numeral⟩ :implicit :restrict (> i 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (= sb (+1 i)))\n")
        afile.write("          (BitVec 1) (BitVec eb) (BitVec i)\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (+oo\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (-oo\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (+zero\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (-zero\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (NaN\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (abs\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb) (FloatingPoint eb sb)))\n")
        afile.write("    (neg\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb) (FloatingPoint eb sb)))\n")
        afile.write("    (add\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          RoundingMode (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (sub\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          RoundingMode (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (mul\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          RoundingMode (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (div\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          RoundingMode (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (fma\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          RoundingMode (FloatingPoint eb sb) (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (sqrt\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          RoundingMode (FloatingPoint eb sb)\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (rem\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (roundToIntegral\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          RoundingMode (FloatingPoint eb sb)\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (min\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (max\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (leq\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          Bool))\n")
        afile.write("    (lt\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          Bool))\n")
        afile.write("    (geq\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          Bool))\n")
        afile.write("    (gt\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          Bool))\n")
        afile.write("    (eq\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb) (FloatingPoint eb sb)\n")
        afile.write("          Bool))\n")
        afile.write("    (isNormal\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb)\n")
        afile.write("          Bool))\n")
        afile.write("    (isSubnormal\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb)\n")
        afile.write("          Bool))\n")
        afile.write("    (isZero\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb)\n")
        afile.write("          Bool))\n")
        afile.write("    (isInfinite\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb)\n")
        afile.write("          Bool))\n")
        afile.write("    (isNaN\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb)\n")
        afile.write("          Bool))\n")
        afile.write("    (isNegative\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb)\n")
        afile.write("          Bool))\n")
        afile.write("    (isPositive\n")
        afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
        afile.write("          (FloatingPoint eb sb)\n")
        afile.write("          Bool))\n")
        if logic_bv :
            afile.write("    (to_fp\n")
            afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :restrict (> eb 1))\n")
            afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :restrict (> sb 1))\n")
            afile.write("          (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (= m (+ sb eb)))\n")
            afile.write("          (BitVec m)\n")
            afile.write("          (FloatingPoint eb sb)))\n")
        afile.write("    (to_fp\n")
        afile.write("      (-> (! Int :var mb :syntax ⟨numeral⟩ :implicit :restrict (> mb 1))\n")
        afile.write("          (! Int :var nb :syntax ⟨numeral⟩ :implicit :restrict (> nb 1))\n")
        afile.write("          (! Int :var eb :syntax ⟨numeral⟩ :restrict (> eb 1))\n")
        afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :restrict (> sb 1))\n")
        afile.write("          RoundingMode\n")
        afile.write("          (FloatingPoint mb nb)\n")
        afile.write("          (FloatingPoint eb sb)))\n")
        if logic_real :
            afile.write("    (to_fp\n")
            afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :restrict (> eb 1))\n")
            afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :restrict (> sb 1))\n")
            afile.write("          RoundingMode\n")
            afile.write("          Real\n")
            afile.write("          (FloatingPoint eb sb)))\n")
        if logic_integer :
            afile.write("    (to_fp_signed\n")
            afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :restrict (> eb 1))\n")
            afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :restrict (> sb 1))\n")
            afile.write("          (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
            afile.write("          RoundingMode\n")
            afile.write("          (BitVec m)\n")
            afile.write("          (FloatingPoint eb sb)))\n")
            afile.write("    (to_fp_unsigned\n")
            afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :restrict (> eb 1))\n")
            afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :restrict (> sb 1))\n")
            afile.write("          (! Int :var m :syntax ⟨numeral⟩ :implicit :restrict (> m 0))\n")
            afile.write("          RoundingMode\n")
            afile.write("          (BitVec m)\n")
            afile.write("          (FloatingPoint eb sb)))\n")
        if logic_bv :
            afile.write("    (to_ubv\n")
            afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
            afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
            afile.write("          (! Int :var m :syntax ⟨numeral⟩ :restrict (> m 0))\n")
            afile.write("          RoundingMode\n")
            afile.write("          (FloatingPoint eb sb)\n")
            afile.write("          (BitVec m)))\n")
            afile.write("    (to_sbv\n")
            afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
            afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
            afile.write("          (! Int :var m :syntax ⟨numeral⟩ :restrict (> m 0))\n")
            afile.write("          RoundingMode\n")
            afile.write("          (FloatingPoint eb sb)\n")
            afile.write("          (BitVec m)))\n")
        if logic_real :
            afile.write("    (to_real\n")
            afile.write("      (-> (! Int :var eb :syntax ⟨numeral⟩ :implicit :restrict (> eb 1))\n")
            afile.write("          (! Int :var sb :syntax ⟨numeral⟩ :implicit :restrict (> sb 1))\n")
            afile.write("          (FloatingPoint eb sb)\n")
            afile.write("          Real))\n")
    afile.write("  )\n\n")
    # Writing special tags
    if logic_fol :
        afile.write(" :FOL\n")
    if not logic_uf :
        afile.write(" :no-new-types\n")
        afile.write(" :no-new-functions\n")
    afile.write(")\n")
    afile.close()
